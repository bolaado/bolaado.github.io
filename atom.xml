<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WONDER</title>
  
  
  <link href="http://github.com/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2021-02-22T01:11:41.636Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>奶糖味小仙女</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>运动物体检测+预测运动方向</title>
    <link href="http://github.com/2021/02/22/%E8%BF%90%E5%8A%A8%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B-%E9%A2%84%E6%B5%8B%E8%BF%90%E5%8A%A8%E6%96%B9%E5%90%91/"/>
    <id>http://github.com/2021/02/22/%E8%BF%90%E5%8A%A8%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B-%E9%A2%84%E6%B5%8B%E8%BF%90%E5%8A%A8%E6%96%B9%E5%90%91/</id>
    <published>2021-02-21T20:13:11.000Z</published>
    <updated>2021-02-22T01:11:41.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运动物体检测-预测运动方向"><a href="#运动物体检测-预测运动方向" class="headerlink" title="运动物体检测+预测运动方向"></a>运动物体检测+预测运动方向</h1><p>一开始的时候我想了好久，都觉得好玄学啊，我在运动的时候，可以乱溜达，我想怎么动怎么动，又不是什么规则的运动，都不是什么可以拟合的曲线，那预测位置多奇怪啊,我可能这一秒的趋势是往前运动，但是我突然想不开非要退一下呢qaq，就感觉有点奇怪</p><h2 id="运动物体检测"><a href="#运动物体检测" class="headerlink" title="运动物体检测"></a>运动物体检测</h2><p>一开始想的是采用背景运动估计的方法去做的，但是在我测试的时候，我固定了摄像头位置，但是由于摄像头好像会自动聚焦然后会有点放大缩小，图像在抖动，而我又是以摄像头读取到的第一帧图像为基础背景去比较的，就导致背景自己就觉得自己在动，就很诡异，效果并不好，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">es = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">9</span>, <span class="number">4</span>))</span><br><span class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">background = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  ret, frame = cap.read()</span><br><span class="line">  gray_img = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">  gray_img = cv2.GaussianBlur(gray_img, (<span class="number">21</span>, <span class="number">21</span>), <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="comment"># 将第一帧设为背景</span></span><br><span class="line">  <span class="keyword">if</span> background <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    background = gray_img</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  img = cv2.absdiff(background, gray_img)</span><br><span class="line">  img = cv2.threshold(img, <span class="number">25</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>] </span><br><span class="line">  img = cv2.dilate(img, es, iterations=<span class="number">2</span>)</span><br><span class="line">  <span class="comment"># 框选</span></span><br><span class="line">  contours, hierarchy = cv2.findContours(img.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">  <span class="keyword">for</span> c <span class="keyword">in</span> contours:</span><br><span class="line">    (x, y, w, h) = cv2.boundingRect(c)</span><br><span class="line">    cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">  cv2.imshow(<span class="string">'contours'</span>, frame)</span><br><span class="line">  cv2.imshow(<span class="string">'dis'</span>, img)</span><br><span class="line"> </span><br><span class="line">  key = cv.waitKey(<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">if</span> key == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">camera.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>然后就改变了想法，采用了光流法，因为很方便就能反馈相邻两帧的相应特征点的坐标，但是缺陷就在于取得特征点有些是无用的<br>其中角点检测我参考的博客是：<br><a href="https://blog.csdn.net/m0_38052500/article/details/106936075" target="_blank" rel="noopener">Harris角点检测数学计算过程与CornerHarris方法参数的一点说明【DataWhale学习记录】</a><br><a href="https://blog.csdn.net/xinyuski/article/details/93472253" target="_blank" rel="noopener">角点检测详细总结及代码示例</a><br>光流法参考的是：<br><a href="https://blog.csdn.net/wendox/article/details/52505971" target="_blank" rel="noopener">SLAM代码（光流法）</a></p><h2 id="运动预测"><a href="#运动预测" class="headerlink" title="运动预测"></a>运动预测</h2><p>我一开始采取的是取相邻两帧之间的特征点的位置,轨迹就是两点连接起来，预测出的运动方向用向量表示，因为没办法直接在图上画出向量，所以我选择了自己计算一下然后用三条线画一个向量出来  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>*(x1 - x0) + x0</span><br><span class="line">y = <span class="number">10</span>*(y1 - y0) + y0</span><br><span class="line">x2 = (x - x0)*cmath.sqrt(<span class="number">2</span>)//<span class="number">2</span> - (y - y0)*cmath.sqrt(<span class="number">2</span>)//<span class="number">2</span> + x0</span><br><span class="line">y2 = (x - x0)*cmath.sqrt(<span class="number">2</span>)//<span class="number">2</span> + (y - y0)*cmath.sqrt(<span class="number">2</span>)//<span class="number">2</span> + y0</span><br><span class="line">x3 = (x - x0)*cmath.sqrt(<span class="number">2</span>)//<span class="number">2</span> + (y - y0)*cmath.sqrt(<span class="number">2</span>)//<span class="number">2</span> + x0</span><br><span class="line">y3 = -(x - x0)*cmath.sqrt(<span class="number">2</span>)//<span class="number">2</span> + (y - y0)*cmath.sqrt(<span class="number">2</span>)//<span class="number">2</span> + y0</span><br><span class="line">cv.line(res, (x0, y0), (int(x), int(y)), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">139</span>), <span class="number">2</span>)</span><br><span class="line">cv.line(res, (int(x), int(y)), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">139</span>), <span class="number">2</span>)</span><br><span class="line">cv.line(res, (int(x), int(y)), (x3, y3), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">139</span>), <span class="number">2</span>)</span><br><span class="line">cv.line(points, (x1, y1), (x0, y0), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">frame = cv.circle(res, (x1, y1), <span class="number">10</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>这样算的话就有一个缺陷，如果物体运动速度快一些的话，向量就会画的很大，运动速度的快慢决定了向量大小<br>如果非要说圈出预测的物体下一帧所在的位置的话，如下：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x4 = <span class="number">2</span>*(x1 - x0) + x0</span><br><span class="line">y4 = <span class="number">2</span>*(y1 - y0) + y0 </span><br><span class="line">cv.circle(res, (int(x4), int(y4)), <span class="number">10</span>, (<span class="number">139</span>, <span class="number">0</span>, <span class="number">139</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2021/02/22/%E8%BF%90%E5%8A%A8%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B-%E9%A2%84%E6%B5%8B%E8%BF%90%E5%8A%A8%E6%96%B9%E5%90%91/1.gif" alt><br>绿色的圈是当前位置，紫色的圈是预测位置，箭头是预测的运动方向<br>很悲伤的是我不想开会员，录屏只让两分钟没啥，mp4转gif的画免费的只有5s，转完了还变快了:shit::shit::shit:</p><h2 id="理想改进"><a href="#理想改进" class="headerlink" title="理想改进"></a>理想改进</h2><p>如果以后还会想做的话，还是想通过运动补偿解决摄像头抖动的问题以达到维持静态背景的效果，然后训练一个运动预测模型，其实如果累计的点合适多的话也是可以当作理想曲线去拟合的</p><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>上传在我的csdn上了<br><a href="https://download.csdn.net/download/Colleron/15416029" target="_blank" rel="noopener">https://download.csdn.net/download/Colleron/15416029</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运动物体检测-预测运动方向&quot;&gt;&lt;a href=&quot;#运动物体检测-预测运动方向&quot; class=&quot;headerlink&quot; title=&quot;运动物体检测+预测运动方向&quot;&gt;&lt;/a&gt;运动物体检测+预测运动方向&lt;/h1&gt;&lt;p&gt;一开始的时候我想了好久，都觉得好玄学啊，我在运动的时</summary>
      
    
    
    
    <category term="-[视觉, OpenCV] -[目标检测]" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89-OpenCV-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
    <category term="Python" scheme="http://github.com/tags/Python/"/>
    
    <category term="目标检测" scheme="http://github.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>CDLL和WinDLL的区别</title>
    <link href="http://github.com/2021/02/06/CDLL%E5%92%8CWinDLL%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://github.com/2021/02/06/CDLL%E5%92%8CWinDLL%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-02-06T13:56:07.000Z</published>
    <updated>2021-02-06T16:38:09.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CDLL和WinDLL的区别"><a href="#CDLL和WinDLL的区别" class="headerlink" title="CDLL和WinDLL的区别"></a>CDLL和WinDLL的区别</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>Python要调用C语言或者C++写的动态连接库，要用到<code>ctypes</code>库<br>而<code>ctypes</code>库其实背后做了很多，它提供了三个easy载入动态连接库的对象：<code>cdll</code>、<code>windll</code>和<code>oledll</code><br>通过访问这三个对象的属性，就能够调用动态连接库的函数了<br><font color="pink">其中</font></p><ul><li><code>cdll</code>主要用来载入C语言调用方式（<code>cdecl</code>）  </li><li><code>windll</code>主要用来载入WIN32调用方式（<code>stdcall</code>）</li><li><code>oledll</code>使用WIN32调用方式（<code>stdcall</code>）且返回值是Windows里返回的HRESULT值<br><font color="BlueViolet">而调用时，最需要注意的去别在于</font><br><font color="Violet"><code>cdll</code>是使用调用者清除的栈的方式。而<code>windll</code>和<code>oledll</code>是使用被调用者清除的方式</font>   </li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="引入ctypes库"><a href="#引入ctypes库" class="headerlink" title="引入ctypes库"></a>引入<code>ctypes</code>库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h3 id="加载dll"><a href="#加载dll" class="headerlink" title="加载dll"></a>加载dll</h3><h4 id="stdcall调用约定"><a href="#stdcall调用约定" class="headerlink" title="stdcall调用约定"></a><code>stdcall</code>调用约定</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objdll = ctypes.WinDLL(<span class="string">"dllpath"</span>)</span><br></pre></td></tr></table></figure><h4 id="cdecl调用约定"><a href="#cdecl调用约定" class="headerlink" title="cdecl调用约定"></a><code>cdecl</code>调用约定</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objdll = ctypes.CDLL(<span class="string">"dllpath"</span>)</span><br></pre></td></tr></table></figure><h2 id="如果有更复杂的使用需求，访问这个"><a href="#如果有更复杂的使用需求，访问这个" class="headerlink" title="如果有更复杂的使用需求，访问这个"></a>如果有更复杂的使用需求，访问这个</h2><p><a href="https://www.cnblogs.com/baihuitestsoftware/articles/5345089.html" target="_blank" rel="noopener">https://www.cnblogs.com/baihuitestsoftware/articles/5345089.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CDLL和WinDLL的区别&quot;&gt;&lt;a href=&quot;#CDLL和WinDLL的区别&quot; class=&quot;headerlink&quot; title=&quot;CDLL和WinDLL的区别&quot;&gt;&lt;/a&gt;CDLL和WinDLL的区别&lt;/h1&gt;&lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot;</summary>
      
    
    
    
    <category term="万千问题" scheme="http://github.com/categories/%E4%B8%87%E5%8D%83%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="Python" scheme="http://github.com/tags/Python/"/>
    
    <category term="C语言" scheme="http://github.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Windows" scheme="http://github.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>C#写上位机调用dll推理库</title>
    <link href="http://github.com/2021/02/06/C%20sharp%E5%86%99%E4%B8%8A%E4%BD%8D%E6%9C%BA%E8%B0%83%E7%94%A8dll%E6%8E%A8%E7%90%86%E5%BA%93/"/>
    <id>http://github.com/2021/02/06/C%20sharp%E5%86%99%E4%B8%8A%E4%BD%8D%E6%9C%BA%E8%B0%83%E7%94%A8dll%E6%8E%A8%E7%90%86%E5%BA%93/</id>
    <published>2021-02-06T08:05:17.000Z</published>
    <updated>2021-02-06T16:35:32.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-写上位机调用dll推理库"><a href="#C-写上位机调用dll推理库" class="headerlink" title="C#写上位机调用dll推理库"></a>C#写上位机调用dll推理库</h1><h2 id="生成dll文件"><a href="#生成dll文件" class="headerlink" title="生成dll文件"></a>生成dll文件</h2><p>移步我的另一篇博客<br><a href="/2021/02/06/生成可供调用的dll推理库/">生成可供调用的dll推理库</a> </p><h2 id="C-上位机调用"><a href="#C-上位机调用" class="headerlink" title="C#上位机调用"></a>C#上位机调用</h2><p>会写的都会写，就没必要多说了，主要是添加上</p><figure class="highlight c"><figcaption><span>sharp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">namespace</span> WindowsFormsApp1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> partial <span class="class"><span class="keyword">class</span> <span class="title">Form1</span> :</span> Form</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [DllImport(<span class="string">"video_detector.dll"</span>, EntryPoint = <span class="string">"CreateModel"</span>, CharSet = CharSet.Ansi)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateModel</span><span class="params">()</span></span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后正常用就完了</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/2021/02/06/C%20sharp%E5%86%99%E4%B8%8A%E4%BD%8D%E6%9C%BA%E8%B0%83%E7%94%A8dll%E6%8E%A8%E7%90%86%E5%BA%93/1.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-写上位机调用dll推理库&quot;&gt;&lt;a href=&quot;#C-写上位机调用dll推理库&quot; class=&quot;headerlink&quot; title=&quot;C#写上位机调用dll推理库&quot;&gt;&lt;/a&gt;C#写上位机调用dll推理库&lt;/h1&gt;&lt;h2 id=&quot;生成dll文件&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="C++" scheme="http://github.com/tags/C/"/>
    
    <category term="PaddleX" scheme="http://github.com/tags/PaddleX/"/>
    
    <category term="Paddle" scheme="http://github.com/tags/Paddle/"/>
    
    <category term="dll" scheme="http://github.com/tags/dll/"/>
    
    <category term="C sharp" scheme="http://github.com/tags/C-sharp/"/>
    
  </entry>
  
  <entry>
    <title>生成可供调用的dll推理库</title>
    <link href="http://github.com/2021/02/06/%E7%94%9F%E6%88%90%E5%8F%AF%E4%BE%9B%E8%B0%83%E7%94%A8%E7%9A%84dll%E6%8E%A8%E7%90%86%E5%BA%93/"/>
    <id>http://github.com/2021/02/06/%E7%94%9F%E6%88%90%E5%8F%AF%E4%BE%9B%E8%B0%83%E7%94%A8%E7%9A%84dll%E6%8E%A8%E7%90%86%E5%BA%93/</id>
    <published>2021-02-06T08:04:17.000Z</published>
    <updated>2021-02-22T01:11:33.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成可供调用的dll推理库"><a href="#生成可供调用的dll推理库" class="headerlink" title="生成可供调用的dll推理库"></a>生成可供调用的dll推理库</h1><h2 id="编辑好-cpp文件"><a href="#编辑好-cpp文件" class="headerlink" title="编辑好.cpp文件"></a>编辑好<code>.cpp</code>文件</h2><p>因为是做目标检测所以我在写检测脚本的时候加入图像处理操作，但是没有单独放接口出来</p><h3 id="添加接口文件"><a href="#添加接口文件" class="headerlink" title="添加接口文件"></a>添加接口文件</h3><p>在头文件中添加接口文件</p><h3 id="接口函数导出"><a href="#接口函数导出" class="headerlink" title="接口函数导出"></a>接口函数导出</h3><p>因为要实现外部调用，所以应给出相应的接口，我使用的是<code>extern &quot;C&quot; __declspec(dllexport)标记方法</code>  的方式进行导出的<br><font color="hotpink">如果是跨语言调用的话，此处注意调用方式的区别，详情参考我的另一篇博客</font><br><a href="/2021/02/06/CDLL和WinDLL的区别/">CDLL和WinDLL的区别</a>   </p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>因为正常的<code>.cpp</code>文件编译后是生成<code>.exe</code>可执行文件且入口函数为<code>int main()</code>，而现在我们是要打包成dll动态推理库，所以我们要将<code>int main()</code> 改造成一个可与外部对接的导出函数<br>网上这里的教程都不太一样，我尝试了几个方案我都使用不通，就根据自己的情况自行修改了<br><img src="/2021/02/06/%E7%94%9F%E6%88%90%E5%8F%AF%E4%BE%9B%E8%B0%83%E7%94%A8%E7%9A%84dll%E6%8E%A8%E7%90%86%E5%BA%93/1.png" alt></p><h2 id="生成dll文件"><a href="#生成dll文件" class="headerlink" title="生成dll文件"></a>生成dll文件</h2><h3 id="打开-项目-gt-属性-gt-常规-gt-配置类型-gt-动态库"><a href="#打开-项目-gt-属性-gt-常规-gt-配置类型-gt-动态库" class="headerlink" title="打开 项目-&gt;属性-&gt;常规-&gt;配置类型-&gt;动态库"></a>打开 项目-&gt;属性-&gt;常规-&gt;配置类型-&gt;动态库</h3><p><img src="/2021/02/06/%E7%94%9F%E6%88%90%E5%8F%AF%E4%BE%9B%E8%B0%83%E7%94%A8%E7%9A%84dll%E6%8E%A8%E7%90%86%E5%BA%93/2.png" alt></p><h3 id="然后生成"><a href="#然后生成" class="headerlink" title="然后生成"></a>然后生成</h3><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在生成的dll文件所在的文件夹下进入powershell，然后执行<code>Python</code>命令<br>然后依次输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">dll = CDLL(dll_path)</span><br><span class="line">print(dll.derived_function())</span><br></pre></td></tr></table></figure><p><font color="Tomato">此处有一些小坑要注意：  </font></p><ul><li>dll_path最好使用绝对路径</li><li>你的dll文件所在的目录一定要加到系统环境变量里，不然你一晚上都不会能读到这个dll文件的，血泪教训！！！  :sob: :cupid:</li><li>当然如果你的dll文件的接口没写好的话也是没法调用的，这个时候就要自行判断问题所在了  </li></ul><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p><img src="/2021/02/06/%E7%94%9F%E6%88%90%E5%8F%AF%E4%BE%9B%E8%B0%83%E7%94%A8%E7%9A%84dll%E6%8E%A8%E7%90%86%E5%BA%93/3.png" alt><br><img src="/2021/02/06/%E7%94%9F%E6%88%90%E5%8F%AF%E4%BE%9B%E8%B0%83%E7%94%A8%E7%9A%84dll%E6%8E%A8%E7%90%86%E5%BA%93/4.png" alt></p><h2 id="上位机中调用"><a href="#上位机中调用" class="headerlink" title="上位机中调用"></a>上位机中调用</h2><p>看我另一篇博客<br><a href="/2021/02/06/C%20sharp写上位机调用dll推理库/">C#写上位机调用dll推理库</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成可供调用的dll推理库&quot;&gt;&lt;a href=&quot;#生成可供调用的dll推理库&quot; class=&quot;headerlink&quot; title=&quot;生成可供调用的dll推理库&quot;&gt;&lt;/a&gt;生成可供调用的dll推理库&lt;/h1&gt;&lt;h2 id=&quot;编辑好-cpp文件&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="C++" scheme="http://github.com/tags/C/"/>
    
    <category term="PaddleX" scheme="http://github.com/tags/PaddleX/"/>
    
    <category term="Paddle" scheme="http://github.com/tags/Paddle/"/>
    
    <category term="dll" scheme="http://github.com/tags/dll/"/>
    
    <category term="目标检测" scheme="http://github.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Github出现连接超时</title>
    <link href="http://github.com/2021/02/06/Github%E5%87%BA%E7%8E%B0%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/"/>
    <id>http://github.com/2021/02/06/Github%E5%87%BA%E7%8E%B0%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/</id>
    <published>2021-02-06T07:40:06.000Z</published>
    <updated>2021-02-06T13:42:07.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github出现连接超时"><a href="#Github出现连接超时" class="headerlink" title="Github出现连接超时"></a>Github出现连接超时</h1><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><font color="hotpink">解决办法</font></h2><h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h3><p><font color="pink">用记事本打开即可</font><br>文件路径在<code>C:\Windows\System32\drivers\etc</code><br>添加上，如下图<br><img src="/2021/02/06/Github%E5%87%BA%E7%8E%B0%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/1.png" alt="1"></p><h4 id="获取要访问的相关网站的IP"><a href="#获取要访问的相关网站的IP" class="headerlink" title="获取要访问的相关网站的IP"></a><font color="purple">获取要访问的相关网站的IP</font></h4><p>访问<a href="https://www.ipaddress.com" target="_blank" rel="noopener">查询IP</a><br>搜索框内分别输入<code>github.com</code>和<code>github.global.ssl.fastly.net</code>查询对应的IP地址，然后如上图所示格式添加上配置就可以了</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>powershell里<code>ping</code>一下   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping github.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Github出现连接超时&quot;&gt;&lt;a href=&quot;#Github出现连接超时&quot; class=&quot;headerlink&quot; title=&quot;Github出现连接超时&quot;&gt;&lt;/a&gt;Github出现连接超时&lt;/h1&gt;&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; cla</summary>
      
    
    
    
    <category term="万千问题" scheme="http://github.com/categories/%E4%B8%87%E5%8D%83%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="Windows" scheme="http://github.com/tags/Windows/"/>
    
    <category term="github" scheme="http://github.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界逆向新手区</title>
    <link href="http://github.com/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/"/>
    <id>http://github.com/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/</id>
    <published>2020-11-21T09:09:56.805Z</published>
    <updated>2021-02-06T13:17:28.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="攻防世界逆向新手区"><a href="#攻防世界逆向新手区" class="headerlink" title="攻防世界逆向新手区"></a><font color="Plum">攻防世界逆向新手区</font></h1><h2 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a><font color="DeepPink">open-source</font></h2><p>从<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/1.png" alt><br>可知first = 0xcafe<br>从<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/2.png" alt><br>可知<br><font color="HotPink">second % 17 = 8<br>strlen(argv[3]) = strlen(“h4cky0u”)</font></p><p>所以直接替换到代码里,然后删掉前面多余的就好啦</p><h2 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple-unpack"></a><font color="DeepPink">simple-unpack</font></h2><p>拿到之后先丢进了ida里，然后<kbd>Shift</kbd>+<kbd>F12</kbd>查找字符串，就看到了<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/3.png" alt><br>发现是upx加壳刚准备去脱壳，手一滑就看到了flag<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/4.png" alt></p><h2 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a><font color="DeepPink">logmein</font></h2><p>查壳没有<br>扔进ida里，在main函数里<kbd>F5</kbd>反编译得到<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/5.png" alt><br>然后分析发现v7要先转为十六进制（末尾的LL表示长长整型）<font color="HotPink">65626d61726168</font><br>然后对着ASCII码表得到<font color="HotPink">ebmarah</font><br>由于x86系列的CPU都是以小端序储存数据的，所以要反过来，<br>即<font color="HotPink">v7=harambe</font><br>看<code>strcpy(v8, &quot;:\&quot;AL_RT^L*.?+6/46&quot;)</code><br>可知<font color="HotPink">v8=:&quot;AL_RT^L*.?+6/46</font><br>然后写个脚本<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/6.png" alt><br>得到的就是flag</p><h2 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a><font color="DeepPink">insanity</font></h2><p>查壳没有<br>直接扔进ida里查找字符串就找到了，不过这个flag长得奇奇怪怪的</p><h2 id="getit"><a href="#getit" class="headerlink" title="getit"></a><font color="DeepPink">getit</font></h2><p>扔进ida里看到了s和t的值<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/7.png" alt><br>然后看主函数的代码分析可以发现<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/8.png" alt><br>就是这一段在定义flag的值，所以拿出来复现就出来了<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/9.png" alt><br>得到flag</p><h2 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a><font color="DeepPink">python-trade</font></h2><p>发现是.pyc文件后拿去在线反编译了<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/10.png" alt><br>分析一下倒回去就OK了<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/11.png" alt></p><h2 id="game"><a href="#game" class="headerlink" title="game"></a><font color="DeepPink">game</font></h2><p>ida里搜索字符串找到一个<font color="Pink">done!!! the flag is</font>然后点进对应的函数里，观察就发现这一段就是出flag的<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/12.png" alt><br>然后写个脚本就出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a1 = [<span class="number">123</span>, <span class="number">32</span>, <span class="number">18</span>, <span class="number">98</span>, <span class="number">119</span>, <span class="number">108</span>, <span class="number">65</span>, <span class="number">41</span>, <span class="number">124</span>, <span class="number">80</span>, <span class="number">125</span>, <span class="number">38</span>, <span class="number">124</span>, <span class="number">111</span>,  <span class="number">74</span>, <span class="number">49</span>, <span class="number">83</span>,</span><br><span class="line">      <span class="number">108</span>, <span class="number">94</span>, <span class="number">108</span>, <span class="number">84</span>, <span class="number">6</span>, <span class="number">96</span>, <span class="number">83</span>, <span class="number">44</span>, <span class="number">121</span>, <span class="number">104</span>, <span class="number">110</span>, <span class="number">32</span>, <span class="number">95</span>, <span class="number">117</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">123</span>,</span><br><span class="line">      <span class="number">127</span>, <span class="number">119</span>, <span class="number">96</span>, <span class="number">48</span>, <span class="number">107</span>, <span class="number">71</span>, <span class="number">92</span>, <span class="number">29</span>, <span class="number">81</span>, <span class="number">107</span>, <span class="number">90</span>, <span class="number">85</span>, <span class="number">64</span>, <span class="number">12</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">86</span>, <span class="number">13</span>,</span><br><span class="line">      <span class="number">114</span>, <span class="number">1</span>, <span class="number">117</span>, <span class="number">126</span>, <span class="number">0</span>]</span><br><span class="line">a2 = [<span class="number">18</span>, <span class="number">64</span>, <span class="number">98</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">65</span>, <span class="number">32</span>, <span class="number">12</span>, <span class="number">48</span>, <span class="number">65</span>, <span class="number">31</span>, <span class="number">78</span>, <span class="number">62</span>, <span class="number">32</span>,</span><br><span class="line">      <span class="number">49</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">57</span>, <span class="number">96</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">44</span>, <span class="number">65</span>, <span class="number">78</span>, <span class="number">32</span>, <span class="number">16</span>,</span><br><span class="line">      <span class="number">97</span>, <span class="number">54</span>, <span class="number">16</span>, <span class="number">44</span>, <span class="number">52</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">89</span>, <span class="number">45</span>, <span class="number">32</span>, <span class="number">65</span>, <span class="number">15</span>, <span class="number">34</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">0</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">56</span>):</span><br><span class="line">    a1[<span class="number">0</span> + i] ^= a2[<span class="number">0</span> + i]</span><br><span class="line">    a1[<span class="number">0</span> + i] ^= <span class="number">0x13</span></span><br><span class="line">    flag = flag + chr(a1[i])</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="Hello-CTF"><a href="#Hello-CTF" class="headerlink" title="Hello, CTF"></a><font color="DeepPink">Hello, CTF</font></h2><p>ida里查找字符串然后我注意到了一串特别的数字<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/14.png" alt><br>直觉告诉我它应该很关键，就点进去了，然后看到<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/15.png" alt><br>然后看了看反编译后的main函数，我发现这一串其实就是输出的有效结果，根据题目提示不一定是明文，就想它应该是加密了然后就感觉是ASCII码然后出来了一串规律字母<font color="HotPink">CrackMeJustForFun</font>，就提交显示正确</p><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a><font color="DeepPink">re1</font></h2><p>ida第三个打开查找字符串就是结果，或者动态调试</p><h2 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no-strings-attached"></a><font color="DeepPink">no-strings-attached</font></h2><p>放进ida里，看main函数，发现<code>authenticate()</code>为关键函数，然后去看<code>authenticate()</code>，发现flag在<code>decrypt()</code>里，然后看汇编代码就发现flag就在eax里，动态调试就可以得到flag了</p><h2 id="csaw2013reversing2"><a href="#csaw2013reversing2" class="headerlink" title="csaw2013reversing2"></a><font color="DeepPink">csaw2013reversing2</font></h2><p>看main函数的反汇编代码<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/16.png" alt><br>看if那一段可以发现，这一段代码并没有执行，因为如果执行的话，程序是会退出弹不出来弹窗的，看MessageBoxA可以发现flag就在IpMem里，所以要跳进if里，但是也要跳过<code>__debugbreak()</code>和<code>ExitProcess(0xFFFFFFFF)</code><br>然后去x32dbg动态调试，做出如下修改<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/17.png" alt><br>跳到第二个flag的地方，再运行出来的弹窗就是正确的flag</p><h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a><font color="DeepPink">maze</font></h2><p>  题目描述里说是一个走迷宫的，所以就在想迷宫应该是方方的，由两种不同的什么组合出来的，可能还有两个入口出口的区别。在ida里找的话应该在Hex-View里看，是一段特殊的,就找到了<br>  <img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/21.png" alt><br>  然后看<code>main()</code>函数的反汇编代码<br>  <img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/19.png" alt><br>就知道flag应该是<font color="HotPink">nctf{中间字符长度为24}</font><br>又看到<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/22.png" alt><br>就可以猜想#对应的23应该是迷宫的终点<br>然后看<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/20.png" alt><br>发现四个关键函数<code>sub_400650() sub_400660() sub_400670() sub_400680()</code>分别应该对应左右上下，看函数的内容有&lt;8，所以应该是个8×8矩阵<br><img src="/2020/11/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E5%8C%BA/23.png" alt><br>入口就应该在左上角<br>就是<font color="HotPink">右下右右下下左下下下右右右右上上左左</font>，对应就能得到flag为<font color="HotPink">nctf{o0oo00O000oooo..OO}</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;攻防世界逆向新手区&quot;&gt;&lt;a href=&quot;#攻防世界逆向新手区&quot; class=&quot;headerlink&quot; title=&quot;攻防世界逆向新手区&quot;&gt;&lt;/a&gt;&lt;font color=&quot;Plum&quot;&gt;攻防世界逆向新手区&lt;/font&gt;&lt;/h1&gt;&lt;h2 id=&quot;open-source</summary>
      
    
    
    
    
    <category term="逆向" scheme="http://github.com/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="re" scheme="http://github.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Markdown编辑公式</title>
    <link href="http://github.com/2020/10/03/Markdown%E7%BC%96%E8%BE%91%E5%85%AC%E5%BC%8F/"/>
    <id>http://github.com/2020/10/03/Markdown%E7%BC%96%E8%BE%91%E5%85%AC%E5%BC%8F/</id>
    <published>2020-10-03T13:23:52.000Z</published>
    <updated>2021-02-06T15:17:50.626Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">    MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script><h1 id="Markdown编辑公式"><a href="#Markdown编辑公式" class="headerlink" title="Markdown编辑公式"></a>Markdown编辑公式</h1><h2 id="行内与行间"><a href="#行内与行间" class="headerlink" title="行内与行间"></a>行内与行间</h2><ul><li>行内公式<br>在公式代码块的基础上前面加上$ ，后面加上$ 组成</li><li>行间公式<br>在公式代码块前后使用$$ 和$$<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th>名称</th><th>大写</th><th>code</th><th>小写</th><th>code</th></tr></thead><tbody><tr><td>alpha</td><td>A</td><td>A</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>beta</td><td>B</td><td>B</td><td>$\beta$</td><td>\beta</td></tr><tr><td>gamma</td><td>$\Gamma$</td><td>\Gamma</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>delta</td><td>$\Delta$</td><td>\Delta</td><td>$\delta$</td><td>\delta</td></tr><tr><td>epsilon</td><td>E</td><td>E</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td>zeta</td><td>Z</td><td>Z</td><td>$\zeta$</td><td>\zeta</td></tr><tr><td>eta</td><td>H</td><td>H</td><td>$\eta$</td><td>\eta</td></tr><tr><td>theta</td><td>$\Theta$</td><td>\Theta</td><td>$\theta$</td><td>\theta</td></tr><tr><td>iota</td><td>I</td><td>I</td><td>$\iota$</td><td>\iota</td></tr><tr><td>kappa</td><td>K</td><td>K</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>lambda</td><td>$\Lambda$</td><td>\Lambda</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>mu</td><td>M</td><td>M</td><td>$\mu$</td><td>\mu</td></tr><tr><td>nu</td><td>N</td><td>N</td><td>$\nu$</td><td>\nu</td></tr><tr><td>xi</td><td>$\Xi$</td><td>\Xi</td><td>$\xi$</td><td>\xi</td></tr><tr><td>omicron</td><td>O</td><td>O</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>pi</td><td>$\Pi$</td><td>\Pi</td><td>$\pi$</td><td>\pi</td></tr><tr><td>rho</td><td>P</td><td>P</td><td>$\rho$</td><td>\rho</td></tr><tr><td>sigma</td><td>$\Sigma$</td><td>\Sigma</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>tau</td><td>T</td><td>T</td><td>$\tau$</td><td>\tau</td></tr><tr><td>upsilon</td><td>Y</td><td>Y</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>phi</td><td>$\Phi$</td><td>\Phi</td><td>$\phi$</td><td>\phi</td></tr><tr><td>chi</td><td>X</td><td>X</td><td>$\chi$</td><td>\chi</td></tr><tr><td>psi</td><td>$\Psi$</td><td>\Psi</td><td>$\psi$</td><td>\psi</td></tr><tr><td>omega</td><td>$\Omega$</td><td>\Omega</td><td>$\omega$</td><td>\omega</td></tr></tbody></table></li></ul><h2 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h2><p><font color="DeepPink">默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{..} 包裹起来的内容</font></p><ul><li>上标<br>^</li><li>下标<br>_</li></ul><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><ul><li>小括号和方括号<ul><li>使用原始的()和[]</li><li>使用\left(或\right)使符号大小与邻近的公式相适应<font color="DeepPink">适用所有括号类型</font></li></ul></li><li>大括号<ul><li>使用<code>\{</code>和<code>\}</code></li><li>使用<code>\lbrace</code>和<code>\rbrace</code></li></ul></li><li>尖括号<ul><li>使用<code>\langle</code>和<code>\rangle</code></li></ul></li><li>上取整  <ul><li>使用<code>\lceil</code>和<code>\rceil</code></li></ul></li><li>下取整<ul><li>使用<code>\lfloor</code>和<code>\rfloor</code> </li></ul></li></ul><h2 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h2><ul><li>求和<br><font color="DeepPink"><code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限</font><ul><li><code>$\sum_{r=1}^n$</code>表示 ：$\sum_{r=1}^n$</li><li><code>$$\sum_{r=1}^n$$</code>表示 :<br>$$\sum_{r=1}^n$$</li></ul></li><li>积分<br><code>\int</code>用来表示积分符号，同样地，其上下标表示积分的上下限。如:<code>$\int_{r=1}^\infty$</code> ： $\int_{r=1}^\infty$<br>多重积分同样使用 int ，通过 i 的数量表示积分导数：<br><code>$\iint$</code> : $\iint$<br><code>$\iiint$</code> : $\iiint$</li><li>连乘<ul><li><code>$\prod {a+b}$</code>，输出：$\prod {a+b}$</li><li><code>$\prod_{i=1}^{K}$</code>，输出：$\prod_{i=1}^{K}$</li></ul></li><li>其他类似<ul><li><code>$\prod$</code> ：$\prod$</li><li><code>$\bigcup$</code> ：$\bigcup$</li><li><code>$\bigcap$</code> ：$\bigcap$</li><li><code>$arg\,\max_{c_k}$</code> ：$arg,\max_{c_k}$</li><li><code>$arg\,\min_{c_k}$</code> ：$arg,\min_{c_k}$</li><li><code>$\mathop {argmin}_{c_k}$</code> : $\mathop {argmin}_{c_k}$</li><li><code>$\mathop {argmax}_{c_k}$</code> : $\mathop {argmax}_{c_k}$</li><li><code>$\max_{c_k}$</code> : $\max_{c_k}$</li><li><code>$\min_{c_k}$</code> : $\min_{c_k}$</li></ul></li></ul><h2 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h2><ul><li>分式<ul><li>使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组,<font color="BlueViolent">可以用{}来分组</font>，如<code>$\frac {a+c+1}{b+c+2}$</code> 表示 $\frac {a+c+1}{b+c+2}$</li><li>使用<code>\over</code>来分隔一个组的前后两部分，如<code>${a+1\over b+1}$</code>：${a+1\over b+1}$</li></ul></li><li>连分数<br>使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code></li><li>根式<ul><li>使用 <code>\sqrt</code> 来表示</li><li>开平方：<code>$\sqrt {a+b}$</code>：$\sqrt {a+b}$</li><li>开四次方：<code>$\sqrt[4]{\frac xy}$</code> : $\sqrt[4]{\frac xy}$</li></ul></li></ul><h2 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h2><ul><li>分类表达式<br><font color="DeepPink">定义函数的时候经常需要分情况给出表达式，使用<code>\begin{cases}…\end{cases}</code> 。其中：</font><ul><li>使用<code>\\</code> 来分类</li><li>使用<code>&amp;</code> 指示需要对齐的位置</li><li>使用<code>\+空格</code>表示空格<br>例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f(n)</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">\cfrac n2, &amp;if\ n\ is\ even\\</span><br><span class="line">3n + 1, &amp;if\  n\ is\ odd</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>表示：<br>$$<br>f(n)<br>\begin{cases}<br>\cfrac n2, &amp;if\ n\ is\ even\<br>3n + 1, &amp;if\  n\ is\ odd<br>\end{cases}<br>$$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">L(Y,f(X)) &#x3D;</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">0, &amp; \text&#123;Y &#x3D; f(X)&#125;  \\</span><br><span class="line">1, &amp; \text&#123;Y $\neq$ f(X)&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>表示：<br>$$<br>L(Y,f(X)) =<br>\begin{cases}<br>0, &amp; \text{Y = f(X)}  \<br>1, &amp; \text{Y $\neq$ f(X)}<br>\end{cases}<br>$$<br><font color="DeepPink">如果想分类之间的垂直间隔变大，可以使用<code>\\[2ex]</code> 代替<code>\\</code> 来分隔不同的情况。<code>(3ex,4ex</code> 也可以用，<code>1ex</code> 相当于原始距离）。如下所示：</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">L(Y,f(X)) &#x3D;</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">0, &amp; \text&#123;Y &#x3D; f(X)&#125; \\[5ex]</span><br><span class="line">1, &amp; \text&#123;Y $\neq$ f(X)&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>表示：<br>$$<br>L(Y,f(X)) =<br>\begin{cases}<br>0, &amp; \text{Y = f(X)} \[5ex]<br>1, &amp; \text{Y $\neq$ f(X)}<br>\end{cases}<br>$$</li></ul></li><li>多行表达式<br><font color="DeepPink">有时候需要将一行公式分多行进行显示</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;equation&#125;\begin&#123;split&#125;  </span><br><span class="line">a&amp;&#x3D;b+c-d \\  </span><br><span class="line">&amp;\quad +e-f \\  </span><br><span class="line">&amp;&#x3D;g+h\\  </span><br><span class="line">&amp;&#x3D; i</span><br><span class="line">\end&#123;split&#125;\end&#123;equation&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>表示：<br>$$<br>\begin{equation}\begin{split}<br>a&amp;=b+c-d \<br>&amp;\quad +e-f \<br>&amp;=g+h\<br>&amp; =i<br>\end{split}\end{equation}<br>$$<br><font color="DeepPink">其中<code>begin{equation}</code> 表示开始方程，<code>end{equation}</code> 表示方程结束；<code>begin{split}</code> 表示开始多行公式，<code>end{split}</code> 表示结束；公式中用<code>\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置</font></li><li>方程组<br><font color="DeepPink">使用<code>\begin{array}...\end{array}</code> 与<code>\left \{</code>与<code>\right.</code> 配合表示方程组:</font>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left \&#123; </span><br><span class="line">\begin&#123;array&#125;&#123;c&#125;</span><br><span class="line">a_1x+b_1y+c_1z&#x3D;d_1 \\ </span><br><span class="line">a_2x+b_2y+c_2z&#x3D;d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z&#x3D;d_3</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>表示：<br>$$<br>\left {<br>\begin{array}{c}<br>a_1x+b_1y+c_1z=d_1 \<br>a_2x+b_2y+c_2z=d_2 \<br>a_3x+b_3y+c_3z=d_3<br>\end{array}<br>\right.<br>$$<br><font color="Tomato">通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code> （.表示空格）都会显示为<code>ab</code> 。可以通过在<code>ab</code> 间加入<code>\</code> ,增加些许间隙，<code>\;</code> 增加较宽的间隙，<code>\quad</code> 与<code>\qquad</code> 会增加更大的间隙</font></li></ul><h2 id="特殊函数与符号"><a href="#特殊函数与符号" class="headerlink" title="特殊函数与符号"></a>特殊函数与符号</h2><ul><li>三角函数<ul><li><code>sin(x)</code> : $sin(x)$</li><li><code>arctan(x)</code> : $arctan(x)$</li><li><code>cos(x)</code> : $cos(x)$</li></ul></li><li>比较运算符<ul><li>小于(<code>\lt</code>)：$\lt$    </li><li>大于(<code>\gt</code>)：$\gt$    </li><li>小于等于(<code>\le</code>)：$\le$    </li><li>大于等于(<code>\ge</code>)：$\ge$   </li><li>不等于(<code>\ne</code>) : $\ne$   </li><li>可以在这些运算符前面加上<code>\not</code> ，如<code>\not\lt</code> : $\not\lt$  </li></ul></li><li>集合关系与运算   <ul><li>并集(<code>\cup</code> ): $\cup$</li><li>交集(<code>\cap</code> ): $\cap$</li><li>差集(<code>\setminus</code> ): $\setminus$</li><li>子集(<code>\subset</code> ): $\subset$</li><li>子集(<code>\subseteq</code> ): $\subseteq$</li><li>非子集(<code>\subsetneq</code> ): $\subsetneq$</li><li>父集(<code>\supset</code> ): $\supset$</li><li>属于(<code>\in</code> ): $\in$</li><li>不属于(<code>\notin</code> ): $\notin$</li><li>空集(<code>\emptyset</code> ): $\emptyset$</li><li>空(<code>\varnothing</code> ): $\varnothing$</li></ul></li><li>排列<ul><li><code>\binom{n+1}{2k}</code> ： $\binom{n+1}{2k}$</li><li><code>{n+1 \choose 2k}</code> : ${n+1 \choose 2k}$</li></ul></li><li>箭头   <ul><li><code>\to</code> : $\to$   </li><li><code>\rightarrow</code> : $\rightarrow$    </li><li><code>\leftarrow</code> : $\leftarrow$    </li><li><code>\Rightarrow</code> : $\Rightarrow$     </li><li><code>\Leftarrow</code> : $\Leftarrow$   </li><li><code>\mapsto</code> : $\mapsto$</li></ul></li><li>逻辑运算符<ul><li><code>\land</code> : $\land$</li><li><code>\lor</code> : $\lor$</li><li><code>\lnot</code> : $\lnot$</li><li><code>\forall</code> : $\forall$</li><li><code>\exists</code> : $\exists$</li><li><code>\top</code> : $\top$</li><li><code>\bot</code> : $\bot$</li><li><code>\vdash</code> : $\vdash$</li><li><code>\vDash</code> : $\vDash$</li></ul></li><li>操作符<br>*<code>\star</code> : $\star$<br>*<code>\ast</code> : $\ast$<br>*<code>\oplus</code> : $\oplus$<br>*<code>\circ</code> : $\circ$<br>*<code>\bullet</code> : $\bullet$</li><li>等于<br>*<code>\approx</code> : $\approx$<br>*<code>\sim</code> : $\sim$<br>*<code>\equiv</code> : $\equiv$<br>*<code>\prec</code> : $\prec$</li><li>范围<br>*<code>\infty</code> : $\infty$<br>*<code>\aleph_o</code> : $\aleph_o$<br>*<code>\nabla</code> : $\nabla$<br>*<code>\Im</code> : $\Im$<br>*<code>\Re</code> : $\Re$    </li><li>模运算<br>*<code>\pmod</code> : $b \pmod n$<br>如<code>a \equiv b \pmod n</code> : $a \equiv b \pmod n$  </li><li>点<br>*<code>\ldots</code> : $\ldots$<br>*<code>\cdots</code> : $\cdots$<br>*<code>\cdot</code> : $\cdot$<br>其区别是点的位置不同，<code>\ldots</code>位置稍低，<code>\cdots</code>位置居中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  $$</span><br><span class="line">  \begin&#123;equation&#125;</span><br><span class="line">  a_1+a_2+\ldots+a_n \\ </span><br><span class="line">  a_1+a_2+\cdots+a_n</span><br><span class="line">  \end&#123;equation&#125;</span><br><span class="line">  $$</span><br><span class="line">  &#96;&#96;&#96;  </span><br><span class="line">  表示：</span><br><span class="line">  $$</span><br><span class="line">  \begin&#123;equation&#125;</span><br><span class="line">  a_1+a_2+\ldots+a_n \\</span><br><span class="line">  a_1+a_2+\cdots+a_n</span><br><span class="line">  \end&#123;equation&#125;</span><br><span class="line">  $$</span><br><span class="line">## 顶部符号</span><br><span class="line">对于单字符，&#96;\hat x&#96; ：$\hat x$  </span><br><span class="line">多字符可以使用&#96;\widehat &#123;xy&#125;&#96; ：$\widehat &#123;xy&#125;$  </span><br><span class="line">类似的还有:  </span><br><span class="line">(\overline x ): \overline x</span><br><span class="line">矢量&#96;\vec&#96; : $\vec x$  </span><br><span class="line">向量&#96;\overrightarrow &#123;xy&#125;&#96; : $\overrightarrow &#123;xy&#125;$  </span><br><span class="line">&#96;\dot x &#96; : $\dot x$  </span><br><span class="line">&#96;\ddot x &#96; : $\ddot x$  </span><br><span class="line">(&#96;dot &#123;\dot x&#125; &#96; : </span><br><span class="line"></span><br><span class="line">## 表格</span><br><span class="line">使用&#96;\begin&#123;array&#125;&#123;列样式&#125;…\end&#123;array&#125;&#96; 这样的形式来创建表格，列样式可以是&#96;clr&#96; 表示居中，左，右对齐，还可以使用&#96;| &#96;表示一条竖线。表格中各行使用&#96;\\&#96; 分隔，各列使用&#96;&amp; &#96;分隔。使用&#96;\hline&#96;在本行前加入一条直线。 例如:</span><br></pre></td></tr></table></figure>$$<br>\begin{array}{c|lcr}<br>n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \<br>\hline<br>1 &amp; 0.24 &amp; 1 &amp; 125 \<br>2 &amp; -1 &amp; 189 &amp; -8 \<br>3 &amp; -20 &amp; 2000 &amp; 1+10i \<br>\end{array}<br>$$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">得到：  </span><br><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\</span><br><span class="line">\hline</span><br><span class="line">1 &amp; 0.24 &amp; 1 &amp; 125 \\</span><br><span class="line">2 &amp; -1 &amp; 189 &amp; -8 \\</span><br><span class="line">3 &amp; -20 &amp; 2000 &amp; 1+10i \\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br><span class="line">## 矩阵</span><br><span class="line">### 基本内容</span><br><span class="line">使用 &#96;\begin&#123;matrix&#125;…\end&#123;matrix&#125;&#96; 这样的形式来表示矩阵，在&#96;\begin&#96; 与&#96;\end&#96; 之间加入矩阵中的元素即可。矩阵的行之间使用&#96;\\&#96; 分隔，列之间使用&#96;&amp;&#96; 分隔，例如:</span><br></pre></td></tr></table></figure>$$<br>\begin{matrix}<br>1 &amp; x &amp; x^2 \<br>1 &amp; y &amp; y^2 \<br>1 &amp; z &amp; z^2 \<br>\end{matrix}<br>$$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">得到:  </span><br><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; x &amp; x^2 \\</span><br><span class="line">1 &amp; y &amp; y^2 \\</span><br><span class="line">1 &amp; z &amp; z^2 \\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">$$</span><br><span class="line">### 括号 </span><br><span class="line">如果要对矩阵加括号，可以像上文中提到的一样，使用&#96;\left&#96; 与&#96;\right&#96; 配合表示括号符号。也可以使用特殊的&#96;matrix&#96; 。即替换&#96;\begin&#123;matrix&#125;…\end&#123;matrix&#125;&#96; 中&#96;matrix&#96; 为&#96;pmatrix&#96; ，&#96;bmatrix&#96; ，&#96;Bmatrix&#96; ，&#96;vmatrix&#96; , &#96;Vmatrix&#96;     </span><br><span class="line">    pmatrix&#96;$\begin&#123;pmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;pmatrix&#125;$&#96; : $\begin&#123;pmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;pmatrix&#125;$  </span><br><span class="line">    bmatrix&#96;$\begin&#123;bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;bmatrix&#125;$&#96; : $\begin&#123;bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;bmatrix&#125;$  </span><br><span class="line">    Bmatrix&#96;$\begin&#123;Bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;Bmatrix&#125;$&#96; : $\begin&#123;Bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;Bmatrix&#125;$  </span><br><span class="line">    vmatrix&#96;$\begin&#123;vmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;vmatrix&#125;$&#96; : $\begin&#123;vmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;vmatrix&#125;$  </span><br><span class="line">### 元素省略</span><br><span class="line">可以使用&#96;\cdots&#96; ：⋯，&#96;\ddots&#96;：⋱ ，&#96;\vdots&#96;：⋮ 来省略矩阵中的元素，如：</span><br></pre></td></tr></table></figure>$$<br>\begin{pmatrix}<br>1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\<br>1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\<br>\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\<br>1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\<br>\end{pmatrix}<br>$$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表示：  </span><br><span class="line">$$</span><br><span class="line">\begin&#123;pmatrix&#125;</span><br><span class="line">1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\</span><br><span class="line">1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\</span><br><span class="line">\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line">1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\</span><br><span class="line">\end&#123;pmatrix&#125;</span><br><span class="line">$$</span><br><span class="line">### 增广矩阵</span><br><span class="line">增广矩阵需要使用前面的表格中使用到的 &#96;\begin&#123;array&#125; ... \end&#123;array&#125;&#96; 来实现</span><br></pre></td></tr></table></figure>$$<br>\left[  \begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线<br>1 &amp; 2 &amp; 3 \<br>\hline %插入横线，如果去掉\hline就是增广矩阵<br>4 &amp; 5 &amp; 6<br>\end{array}  \right]<br>$$<pre><code>显示为：$$\left[  \begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线1 &amp; 2 &amp; 3 \\\hline %插入横线，如果去掉\hline就是增广矩阵4 &amp; 5 &amp; 6\end{array}  \right]$$</code></pre></li></ul><h2 id="公式标记与引用"><a href="#公式标记与引用" class="headerlink" title="公式标记与引用"></a>公式标记与引用</h2><p>  使用<code>\tag{yourtag}</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\label{yourlabel}</code> 在<code>\tag</code> 之后，如<code>$$a = x^2 - y^3 \tag{1}\labe{1}$$</code> 显示为：<br>$$a := x^2 - y^3 \tag{1}\labe{1}$$<br>  如果不需要被引用，只使用<code>\tag{yourtag}</code> ，<code>$$x+y=z\tag{1.1}$$</code>显示为：<br>$$x+y=z\tag{1.1}$$<br>  <code>\tab{yourtab}</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\label{}</code> 设置的内容来引用。为了引用公式，可以使用<code>\eqref{yourlabel}</code> ，如<code>$$a + y^3 \stackrel{\eqref{1}}= x^2$$</code> 显示为：<br>$$a + y^3 \stackrel{\eqref{1}}= x^2$$</p><p>或者使用<code>\ref{yourlabel}</code> 不带括号引用，如<code>$$a + y^3 \stackrel{\ref{111}}= x^2$$</code> 显示为:<br>$$a + y^3 \stackrel{\ref{1}}= x^2$$</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="黑板粗字体"><a href="#黑板粗字体" class="headerlink" title="黑板粗字体"></a>黑板粗字体</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br><code>$\mathbb ABCDEF$</code>：$\mathbb ABCDEF$<br><code>$\Bbb ABCDEF$</code>：$\Bbb ABCDEF$</p><h3 id="黑体字"><a href="#黑体字" class="headerlink" title="黑体字"></a>黑体字</h3><p><code>$\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> : $\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$<br><code>$\mathbf abcdefghijklmnopqrstuvwxyz$</code> : $\mathbf abcdefghijklmnopqrstuvwxyz$</p><h3 id="打印机字体"><a href="#打印机字体" class="headerlink" title="打印机字体"></a>打印机字体</h3><p><code>$\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> : $\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>直接输入地址</p><h2 id="Emoji小表情"><a href="#Emoji小表情" class="headerlink" title="Emoji小表情"></a>Emoji小表情</h2><p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;t</summary>
      
    
    
    
    <category term="Markdown" scheme="http://github.com/categories/Markdown/"/>
    
    
    <category term="日用" scheme="http://github.com/tags/%E6%97%A5%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>卡尔曼Kalman滤波跟踪</title>
    <link href="http://github.com/2020/10/03/%E5%8D%A1%E5%B0%94%E6%9B%BCKalman%E6%BB%A4%E6%B3%A2%E8%B7%9F%E8%B8%AA/"/>
    <id>http://github.com/2020/10/03/%E5%8D%A1%E5%B0%94%E6%9B%BCKalman%E6%BB%A4%E6%B3%A2%E8%B7%9F%E8%B8%AA/</id>
    <published>2020-10-03T13:20:55.000Z</published>
    <updated>2021-02-22T01:11:35.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卡尔曼Kalman滤波跟踪"><a href="#卡尔曼Kalman滤波跟踪" class="headerlink" title="卡尔曼Kalman滤波跟踪"></a>卡尔曼Kalman滤波跟踪</h1><p>kalman滤波：<br>1.用上一次的最优状态估计和最优估计误差去计算这一次的先验状态估计和先验误差估计；<br>2.用1得到的本次先验误差估计和测量噪声，得到卡尔曼增益；<br>3.用1，2步骤得到所有先验误差估计和测量噪声，得到本次的最优估计。<br><font color="DeepPink">总结：对模型的预测值和实际的观测值进行加权，迭代计算出未来的状态</font></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>卡尔曼的核心：预测＋反馈  </li><li>卡尔曼滤波算法分为两个阶段：  <ul><li>预测阶段：卡尔曼滤波器使用由当前点计算的协方差来估计目标的新位置；  </li><li>更新阶段：卡尔曼滤波器记录目标的位置，并为下一次循环计算修正协方差。</li></ul></li><li>观测数据：可能存在或多或少的误差的采集的实际数据  </li><li>最优估计：算法计算出来接近于真实值的估计    </li><li>均方误差：误差（每个估计值与真实值的差）的平方，再求和，再求平均。多样本时，均方误差等于每个样本的误差平方乘以该样本出现的概率，再求和。   </li><li>方差：描述随机变量的离散程度，具体来说是变量值离期望值的距离。    </li><li>最小均方误差估计：估计参数，使得估计出来的模型和真实值之间的误差平方期望最小。   </li><li>两个变量之间的协方差：在协方差矩阵中，对角线元素即为方差。x, y都大于期望，协方差为正值。</li></ul><h2 id="核心公式"><a href="#核心公式" class="headerlink" title="核心公式"></a>核心公式</h2><font color="HotPink">对于离散控制过程的系统，其系统状态和系统测量值可进行以下表示：    <p>X(k) = AX(k-1) + BU(k) + W(k)<br>Z(k) = HX(k) + V(k)<br></p></font><p></p><ul><li>X(k)： k时刻系统状态</li><li>A: 状态转移矩阵，对应opencv里kalman滤波器的transitionMatrix矩阵</li><li>B: 控制输入矩阵，对应opencv里kalman滤波器的controlMatrix矩阵</li><li>H：系统测量矩阵，对应opencv里kalman滤波器的measurementMatrix矩阵</li><li>U(k)：k时刻对系统的控制量</li><li>Z(k)：k时刻的测量值</li><li>W(k)：系统过程噪声，为高斯白噪声，协方差为Q，对应opencv里的kalman滤波器的processNoiseCov矩阵</li><li>V(k)：测量噪声，也为高斯白噪声，协方差为R，对应opencv里的kalman滤波器的measurementNoiseCov矩阵 </li></ul><font color="Crimson">真正核心的五个公式：    <p>$X(k|k-1) = AX(k-1|k-1) + BU(k)$<br>$P(k|k-1) = AP(k-1|k-1)A^T + Q$<br>$Kg(k) = {P(k|k-1)H^T\over HP(k|k-1)H^T + R}$<br>$X(k|k) = X(k|k-1) + Kg(k)(Z(k) - HK(k|k-1))$<br>$P(k|k) = (1-Kg(k)H)P(k|k-1)$<br></p></font><p></p><ul><li><p>预测值的计算</p><ul><li>式(1)：计算基于k-1时刻状态对k时刻系统状态的预测值<ul><li>X(k|k-1)：基于k-1时刻状态对k时刻状态的预测值，对应opencv里kalman滤波器的predict()输出，即statePre矩阵</li><li>X(k-1|k-1)：k-1时刻状态的最优结果，对应opencv里kalman滤波器的上一次状态的statePost矩阵</li><li>U(k)：k时刻的系统控制量，无则为0</li><li>A：状态转移矩阵，对应opencv里kalman滤波器的transitionMatrix矩阵</li><li>B：控制输入矩阵，对应opencv里kalman滤波器的controlMatrix矩阵</li></ul></li><li>式(2)：计算X(k|k-1)对应的协方差的预测值<ul><li>P(k|k-1)：   基于k-1时刻的协方差计算k时刻协方差的预测值，对应opencv里kalman滤波器的errorCovPre矩阵</li><li>P(k-1|k-1)：k-1时刻协方差的最优结果，对应opencv里kalman滤波器的上一次状态的errorCovPost矩阵</li><li>Q：系统过程噪声协方差，对应opencv里kalman滤波器的processNoiseCov矩阵</li></ul></li></ul></li><li><p>增益的计算</p><ul><li>Kg(k)：k时刻的kalman增益，为估计量的方差占总方差(估计量方差和测量方差)的比重，对应opencv里kalman滤波器的gain矩阵</li><li>H：系统测量矩阵，对应opencv里kalman滤波器的measurementMatrix矩阵</li><li>R： 测量噪声协方差，对应opencv里的kalman滤波器的measurementNoiseCov矩阵</li></ul></li><li><p>k时刻的更新</p><ul><li>式(4)：计算k时刻系统状态最优值    <ul><li>X(k|k)：k时刻系统状态的最优结果，对应opencv里kalman滤波器的k时刻状态的statePost矩阵     </li><li>Z(k)：k时刻系统测量值</li></ul></li><li>式(5)：计算k时刻系统最优结果对应的协方差<ul><li>P(k|k)：k时刻系统最优结果对应的协方差，对应opencv里kalman滤波器的errorCovPost矩阵</li></ul></li></ul></li><li><p>输出即为X(k|k)，k时刻系统状态最优估计值。 </p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">minGreen = (<span class="number">35</span>, <span class="number">43</span>, <span class="number">46</span>)</span><br><span class="line">maxGreen = (<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">stateSize = <span class="number">6</span></span><br><span class="line">measSize = <span class="number">4</span></span><br><span class="line">coutrSize = <span class="number">0</span></span><br><span class="line">kf = cv2.KalmanFilter(stateSize, measSize, coutrSize)</span><br><span class="line">state = np.zeros(stateSize, np.float32)</span><br><span class="line">meas = np.zeros(measSize, np.float32)</span><br><span class="line">procNoise = np.zeros(stateSize, np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv2.setIdentity(kf.transitionMatrix)</span><br><span class="line"></span><br><span class="line">kf.measurementMatrix = np.zeros((measSize, stateSize), np.float32)</span><br><span class="line">kf.measurementMatrix[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">kf.measurementMatrix[<span class="number">1</span>, <span class="number">1</span>] = <span class="number">1.0</span></span><br><span class="line">kf.measurementMatrix[<span class="number">2</span>, <span class="number">4</span>] = <span class="number">1.0</span></span><br><span class="line">kf.measurementMatrix[<span class="number">3</span>, <span class="number">5</span>] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">cv2.setIdentity(kf.processNoiseCov)</span><br><span class="line">kf.processNoiseCov[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">1e-2</span></span><br><span class="line">kf.processNoiseCov[<span class="number">1</span>, <span class="number">1</span>] = <span class="number">1e-2</span></span><br><span class="line">kf.processNoiseCov[<span class="number">2</span>, <span class="number">2</span>] = <span class="number">5.0</span></span><br><span class="line">kf.processNoiseCov[<span class="number">3</span>, <span class="number">3</span>] = <span class="number">5.0</span></span><br><span class="line">kf.processNoiseCov[<span class="number">4</span>, <span class="number">4</span>] = <span class="number">1e-2</span></span><br><span class="line">kf.processNoiseCov[<span class="number">5</span>, <span class="number">5</span>] = <span class="number">1e-2</span></span><br><span class="line"></span><br><span class="line">cv2.setIdentity(kf.measurementNoiseCov)</span><br><span class="line"></span><br><span class="line">video_cap = cv2.VideoCapture(<span class="string">'F:/test/1.mp4'</span>)</span><br><span class="line">fps = video_cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">size = (int(video_cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(video_cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line">videoWriter = cv2.VideoWriter(<span class="string">'F:/2.mp4'</span>, cv2.VideoWriter_fourcc(<span class="string">'m'</span>, <span class="string">'p'</span>, <span class="string">'4'</span>, <span class="string">'v'</span>), fps, size)</span><br><span class="line">ticks = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">found = <span class="literal">False</span></span><br><span class="line">notFoundCount = <span class="number">0</span></span><br><span class="line">prePointCen = []</span><br><span class="line">meaPointCen = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = video_cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>, frame)</span><br><span class="line">    cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    precTick = ticks</span><br><span class="line">    ticks = float(cv2.getTickCount())</span><br><span class="line">    res = frame.copy()</span><br><span class="line">    dT = float((ticks - precTick)/cv2.getTickFrequency())</span><br><span class="line">    <span class="keyword">if</span> found:</span><br><span class="line">        kf.transitionMatrix[<span class="number">0</span>, <span class="number">2</span>] = dT</span><br><span class="line">        kf.transitionMatrix[<span class="number">1</span>, <span class="number">3</span>] = dT</span><br><span class="line"></span><br><span class="line">        state = kf.predict()</span><br><span class="line">        width = state[<span class="number">4</span>]</span><br><span class="line">        height = state[<span class="number">5</span>]</span><br><span class="line">        x_left = state[<span class="number">0</span>] - width/<span class="number">2</span></span><br><span class="line">        y_left = state[<span class="number">1</span>] - height/<span class="number">2</span></span><br><span class="line">        x_right = state[<span class="number">0</span>] + width/<span class="number">2</span></span><br><span class="line">        y_right = state[<span class="number">1</span>] + height/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        center_x = state[<span class="number">0</span>]</span><br><span class="line">        center_y = state[<span class="number">1</span>]</span><br><span class="line">        prePointCen.append((int(center_x), int(center_y)))</span><br><span class="line"></span><br><span class="line">    frame = cv2.GaussianBlur(frame, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">3.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line">    rangeRes = cv2.inRange(frame, minGreen, maxGreen)</span><br><span class="line">    kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">    rangeRes = cv2.erode(rangeRes, kernel, iterations=<span class="number">2</span>)</span><br><span class="line">    rangeRes = cv2.dilate(rangeRes, kernel, iterations=<span class="number">2</span>)</span><br><span class="line">    cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    contours = cv2.findContours(rangeRes.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[<span class="number">-2</span>]</span><br><span class="line">    target = []</span><br><span class="line">    Box = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(contours)):</span><br><span class="line">        x, y, w, h = cv2.boundingRect(np.array(contours[i]))</span><br><span class="line"></span><br><span class="line">        ratio = float(w/h)</span><br><span class="line">        <span class="keyword">if</span> ratio &gt; <span class="number">1.0</span>:</span><br><span class="line">            ratio = <span class="number">1.0</span> / ratio</span><br><span class="line">        <span class="keyword">if</span> ratio &gt; <span class="number">0.75</span> <span class="keyword">and</span> w*h &gt;= <span class="number">400</span>:</span><br><span class="line">            target.append(contours[i])</span><br><span class="line">            Box.append([x, y, w, h])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(target)):</span><br><span class="line">        cv2.drawContours(res, target, i, (<span class="number">20</span>, <span class="number">150</span>, <span class="number">20</span>), <span class="number">1</span>)</span><br><span class="line">        cv2.rectangle(res, (Box[i][<span class="number">0</span>], Box[i][<span class="number">1</span>]), (Box[i][<span class="number">0</span>]+Box[i][<span class="number">2</span>], Box[i][<span class="number">1</span>]+Box[i][<span class="number">3</span>]), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        center_x = Box[i][<span class="number">0</span>] + Box[i][<span class="number">2</span>] / <span class="number">2</span></span><br><span class="line">        center_y = Box[i][<span class="number">1</span>] + Box[i][<span class="number">3</span>] / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        meaPointCen.append((int(center_x), int(center_y)))</span><br><span class="line">        cv2.circle(res, (int(center_x), int(center_y)), <span class="number">2</span>, (<span class="number">20</span>, <span class="number">150</span>, <span class="number">20</span>), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        name = <span class="string">"("</span> + str(center_x) + <span class="string">","</span> + str(center_y) + <span class="string">")"</span></span><br><span class="line">        cv2.putText(res, name, (int(center_x) + <span class="number">3</span>, int(center_y) - <span class="number">3</span>), cv2.FONT_HERSHEY_COMPLEX, <span class="number">0.5</span>, (<span class="number">20</span>, <span class="number">150</span>, <span class="number">20</span>), <span class="number">2</span>)</span><br><span class="line">    n = len(prePointCen)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> prePointCen[i<span class="number">-1</span>] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> prePointCen[i] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cv2.line(res, prePointCen[i<span class="number">-1</span>], prePointCen[i], (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> len(target) == <span class="number">0</span>:</span><br><span class="line">        notFoundCount += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> notFoundCount &gt;= <span class="number">100</span>:</span><br><span class="line">            found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        notFoundCount = <span class="number">0</span></span><br><span class="line">        meas[<span class="number">0</span>] = Box[<span class="number">0</span>][<span class="number">0</span>] + Box[<span class="number">0</span>][<span class="number">2</span>] / <span class="number">2</span></span><br><span class="line">        meas[<span class="number">1</span>] = Box[<span class="number">0</span>][<span class="number">1</span>] + Box[<span class="number">0</span>][<span class="number">3</span>] / <span class="number">2</span></span><br><span class="line">        meas[<span class="number">2</span>] = float(Box[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">        meas[<span class="number">3</span>] = float(Box[<span class="number">0</span>][<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(kf.errorCovPre)):</span><br><span class="line">                kf.errorCovPre[i, i] = <span class="number">1</span></span><br><span class="line">            state[<span class="number">0</span>] = meas[<span class="number">0</span>]</span><br><span class="line">            state[<span class="number">1</span>] = meas[<span class="number">1</span>]</span><br><span class="line">            state[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">            state[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">            state[<span class="number">4</span>] = meas[<span class="number">2</span>]</span><br><span class="line">            state[<span class="number">5</span>] = meas[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">            kf.statePost = state</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            kf.correct(meas)  <span class="comment"># Kalman修正</span></span><br><span class="line">            cv2.imshow(<span class="string">"res"</span>, res)</span><br><span class="line">            cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    videoWriter.write(res)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/2020/10/03/%E5%8D%A1%E5%B0%94%E6%9B%BCKalman%E6%BB%A4%E6%B3%A2%E8%B7%9F%E8%B8%AA/1.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;卡尔曼Kalman滤波跟踪&quot;&gt;&lt;a href=&quot;#卡尔曼Kalman滤波跟踪&quot; class=&quot;headerlink&quot; title=&quot;卡尔曼Kalman滤波跟踪&quot;&gt;&lt;/a&gt;卡尔曼Kalman滤波跟踪&lt;/h1&gt;&lt;p&gt;kalman滤波：&lt;br&gt;1.用上一次的最优状态估计</summary>
      
    
    
    
    <category term="视觉" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89/"/>
    
    <category term="OpenCV" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89/OpenCV/"/>
    
    
    <category term="Python" scheme="http://github.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>四种去噪操作</title>
    <link href="http://github.com/2020/10/03/%E5%9B%9B%E7%A7%8D%E5%8E%BB%E5%99%AA%E6%93%8D%E4%BD%9C/"/>
    <id>http://github.com/2020/10/03/%E5%9B%9B%E7%A7%8D%E5%8E%BB%E5%99%AA%E6%93%8D%E4%BD%9C/</id>
    <published>2020-10-03T12:18:06.000Z</published>
    <updated>2021-02-06T15:14:23.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四种常见的去噪操作"><a href="#四种常见的去噪操作" class="headerlink" title="四种常见的去噪操作"></a>四种常见的去噪操作</h1><h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p>当对一个值进行滤波时，使用当前值与周围8个值之和，取平均做为当前值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 第二个参数代表进行均值滤波的方框大小</span></span><br></pre></td></tr></table></figure><h2 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.boxfilter(img, <span class="number">-1</span>, (<span class="number">3</span>, <span class="number">3</span>), normalize=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 当normalize=True时，与均值滤波结果相同， normalize=False，表示对加和后的九个点不进行平均操作，大于255的使用255表示</span></span><br></pre></td></tr></table></figure><h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p>$$<br>G(x) =<br>\begin{cases}<br>\frac {1}{\sqrt{2\pi}\sigma}e^{-\frac {x^2}{2 \sigma^2}}<br>\end{cases}<br>$$<br>根据高斯的距离对周围的点进行加权,求平均值1，0.8， 0.6， 0.8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.Guassianblur(img, (<span class="number">3</span>, <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1表示σ， x表示与当前值得距离，计算出的G(x)表示权重值</span></span><br></pre></td></tr></table></figure><h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p>相当于将9个值进行排序，取中值作为当前值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.medianBlur(img, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 3表示当前的方框尺寸</span></span><br></pre></td></tr></table></figure><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = np.vstack(要合并的几个图像名，用逗号分隔)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四种常见的去噪操作&quot;&gt;&lt;a href=&quot;#四种常见的去噪操作&quot; class=&quot;headerlink&quot; title=&quot;四种常见的去噪操作&quot;&gt;&lt;/a&gt;四种常见的去噪操作&lt;/h1&gt;&lt;h2 id=&quot;均值滤波&quot;&gt;&lt;a href=&quot;#均值滤波&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="视觉" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89/"/>
    
    <category term="OpenCV" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89/OpenCV/"/>
    
    
    <category term="Python" scheme="http://github.com/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://github.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Python中的reshape()</title>
    <link href="http://github.com/2020/10/02/Python%E4%B8%AD%E7%9A%84reshape/"/>
    <id>http://github.com/2020/10/02/Python%E4%B8%AD%E7%9A%84reshape/</id>
    <published>2020-10-02T12:43:01.000Z</published>
    <updated>2021-02-06T13:32:24.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的reshape"><a href="#Python中的reshape" class="headerlink" title="Python中的reshape()"></a>Python中的reshape()</h1><p><code>reshape(x, newshape, order=&#39;C&#39;)</code><br>reshape函数用于改变数组形状，且原数据不发生变化</p><h2 id="order参数"><a href="#order参数" class="headerlink" title="order参数"></a>order参数</h2><p>其中<code>order=&#39;C&#39;</code>代表是按照行顺序，<br>如果是F则是按照列顺序，<br>如果是A则是按照数据在内存中存储的顺序来  </p><h2 id="x参数"><a href="#x参数" class="headerlink" title="x参数"></a>x参数</h2><p>代表新数组行数</p><h2 id="newshape参数"><a href="#newshape参数" class="headerlink" title="newshape参数"></a>newshape参数</h2><p>代表新数组列数<br><font color="HotPink">当x=-1的时候，newshape给定列数，行数则由Numpy自行计算<br>当newshape=-1的时候，x给定行数，列数则由Numpy自行计算<br></font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python中的reshape&quot;&gt;&lt;a href=&quot;#Python中的reshape&quot; class=&quot;headerlink&quot; title=&quot;Python中的reshape()&quot;&gt;&lt;/a&gt;Python中的reshape()&lt;/h1&gt;&lt;p&gt;&lt;code&gt;reshape(</summary>
      
    
    
    
    
    <category term="Python" scheme="http://github.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>opencv绘图函数</title>
    <link href="http://github.com/2020/10/02/opencv%E7%BB%98%E5%9B%BE%E5%87%BD%E6%95%B0/"/>
    <id>http://github.com/2020/10/02/opencv%E7%BB%98%E5%9B%BE%E5%87%BD%E6%95%B0/</id>
    <published>2020-10-02T11:24:03.000Z</published>
    <updated>2021-02-06T13:31:50.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opencv绘图函数"><a href="#opencv绘图函数" class="headerlink" title="opencv绘图函数"></a>opencv绘图函数</h1><p><font color="BlueViolet">首先要创造一个背景图，</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img=np.zeros((像素高,像素宽,<span class="number">3</span>), np.uint8)</span><br><span class="line"><span class="comment"># 3代表BGR三种颜色，uint8是用0-255表示所有颜色，此时为黑色背景</span></span><br></pre></td></tr></table></figure><p>其实np.zeros()只两个参数，第一个是创建的图片矩阵大小，第二个是数据类型，所以<code>np.uint8</code>可以被<code>(B, G, R)</code>代替，这样就可以改变背景颜色<br></p><h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    cv2.line(图像名, 起点坐标, 终点坐标, 颜色数组, 线宽)</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">## 矩形</span><br></pre></td></tr></table></figure><pre><code>cv2.rectangle(图像名, 左上顶点坐标, 右下顶点左边, 颜色数组, 线宽)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color&#x3D;&quot;DeepPink&quot;&gt;当线宽为-1时，表示封闭图形的颜色填充&lt;&#x2F;font&gt;</span><br><span class="line">## 圆</span><br><span class="line">&#96;&#96;&#96;Python</span><br><span class="line">    cv2.circle(图像名, 圆心坐标, 半径, 颜色数组, 线宽)</span><br></pre></td></tr></table></figure><h2 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.ellipse(图像名, 中心坐标, (长轴长, 短轴长), 椭圆沿逆时针方向旋转的角度, 长轴顺时针方向起始的角度, 结束角度, 颜色数组, 线宽)</span><br></pre></td></tr></table></figure><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pts = np.array([顶点列表], np.int32)</span><br><span class="line">pts = pts.reshape((<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">img = cv2.polylines(图像名, [pts], <span class="literal">True</span>, 颜色数组, 线宽)</span><br></pre></td></tr></table></figure><p><font color="Yellow">关于<code>reshape()</code>函数可以看我的另一篇博客</font><br><a href="https://bolaado.github.io/2020/10/02/Python%E4%B8%AD%E7%9A%84reshape/" target="_blank" rel="noopener">https://bolaado.github.io/2020/10/02/Python%E4%B8%AD%E7%9A%84reshape/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;opencv绘图函数&quot;&gt;&lt;a href=&quot;#opencv绘图函数&quot; class=&quot;headerlink&quot; title=&quot;opencv绘图函数&quot;&gt;&lt;/a&gt;opencv绘图函数&lt;/h1&gt;&lt;p&gt;&lt;font color=&quot;BlueViolet&quot;&gt;首先要创造一个背景图，&lt;/</summary>
      
    
    
    
    <category term="视觉" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89/"/>
    
    <category term="OpenCV" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89/OpenCV/"/>
    
    
    <category term="Python" scheme="http://github.com/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://github.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>PaddlePaddle安装</title>
    <link href="http://github.com/2020/10/01/PaddlePaddle%E5%AE%89%E8%A3%85/"/>
    <id>http://github.com/2020/10/01/PaddlePaddle%E5%AE%89%E8%A3%85/</id>
    <published>2020-10-01T14:19:37.000Z</published>
    <updated>2021-02-06T13:38:31.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装paddle（飞桨）"><a href="#安装paddle（飞桨）" class="headerlink" title="安装paddle（飞桨）"></a>安装paddle（飞桨）</h1><p>cmd里敲<br>CPU版<br><code>conda install paddlepaddle</code><br>GPU版  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># CUDA 9，cuDNN 7.3+:</span><br><span class="line">conda install paddlepaddle-gpu cudatoolkit&#x3D;9.0</span><br><span class="line"># CUDA 10.0，cuDNN 7.3+</span><br><span class="line">conda install paddlepaddle-gpu cudatoolkit&#x3D;10.0</span><br></pre></td></tr></table></figure><p>没有vpn的话就得换源，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;Paddle&#x2F;</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p><font color="DeepPink">在命令行里可能敲了<code>-</code>之后，<code>-</code>以及它后面的命令都不会被显示出来，直到有一个空格，也就是说<code>-add</code>可能不会显示出来，这都是正常的，我也不知道为什么之前是不会隐藏的现在突然变了，可能有的人使用的时候并不会</font></p><p>如果出现了问题，看我的另一篇博客<br><a href="https://bolaado.github.io/2020/10/01/Solving-environment-failed-with-initial-frozen-solve-Retrying-with-flexible-solve/" target="_blank" rel="noopener">https://bolaado.github.io/2020/10/01/Solving-environment-failed-with-initial-frozen-solve-Retrying-with-flexible-solve/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装paddle（飞桨）&quot;&gt;&lt;a href=&quot;#安装paddle（飞桨）&quot; class=&quot;headerlink&quot; title=&quot;安装paddle（飞桨）&quot;&gt;&lt;/a&gt;安装paddle（飞桨）&lt;/h1&gt;&lt;p&gt;cmd里敲&lt;br&gt;CPU版&lt;br&gt;&lt;code&gt;conda i</summary>
      
    
    
    
    <category term="安装" scheme="http://github.com/categories/%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="Windows" scheme="http://github.com/tags/Windows/"/>
    
    <category term="paddle" scheme="http://github.com/tags/paddle/"/>
    
  </entry>
  
  <entry>
    <title>Solving environment: failed with initial frozen solve.Retrying with flexible solve</title>
    <link href="http://github.com/2020/10/01/Solving-environment-failed-with-initial-frozen-solve-Retrying-with-flexible-solve/"/>
    <id>http://github.com/2020/10/01/Solving-environment-failed-with-initial-frozen-solve-Retrying-with-flexible-solve/</id>
    <published>2020-10-01T13:49:40.000Z</published>
    <updated>2021-02-06T13:28:28.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solving-environment-failed-with-initial-frozen-solve-Retrying-with-flexible-solve"><a href="#Solving-environment-failed-with-initial-frozen-solve-Retrying-with-flexible-solve" class="headerlink" title="Solving environment: failed with initial frozen solve.Retrying with flexible solve"></a>Solving environment: failed with initial frozen solve.Retrying with flexible solve</h1><p>用conda装paddle的时候出现了这个报错  </p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><code>conda update -n base conda</code><br><code>conda update --all</code><br><font color="BlueViolet">然后如果还是不行，就再加一行（但实际上大部分情况这样就可以了）</font><br><code>conda update --prefix</code><br>会自己跳出来一段后面的目录，不用管它回车就行了，然后常规操作，我挑出来过是否允许python.exe都点允许，然后命令行出现y/n就都填y就好，完成后再一次<code>conda update --all</code><br>最后安装好之后，尝试一下进入python解释器，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import paddle.fluid</span><br><span class="line">paddle.fluid.install_check.run_check()</span><br></pre></td></tr></table></figure><p>出现如下图就成功了<br><img src="/2020/10/01/Solving-environment-failed-with-initial-frozen-solve-Retrying-with-flexible-solve/1.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Solving-environment-failed-with-initial-frozen-solve-Retrying-with-flexible-solve&quot;&gt;&lt;a href=&quot;#Solving-environment-failed-with-initial</summary>
      
    
    
    
    <category term="安装" scheme="http://github.com/categories/%E5%AE%89%E8%A3%85/"/>
    
    <category term="遇见的问题" scheme="http://github.com/categories/%E5%AE%89%E8%A3%85/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="paddle" scheme="http://github.com/tags/paddle/"/>
    
    <category term="conda" scheme="http://github.com/tags/conda/"/>
    
  </entry>
  
  <entry>
    <title>QGC安装</title>
    <link href="http://github.com/2020/10/01/QGC%E5%AE%89%E8%A3%85/"/>
    <id>http://github.com/2020/10/01/QGC%E5%AE%89%E8%A3%85/</id>
    <published>2020-10-01T12:31:57.000Z</published>
    <updated>2021-02-06T13:34:51.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QGC安装"><a href="#QGC安装" class="headerlink" title="QGC安装"></a>QGC安装</h1><p>大部分的教程都太老了所以整理了一下自己写了一套</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>直接百度QGC选第一个进官网，进去后如下所示<br><img src="/2020/10/01/QGC%E5%AE%89%E8%A3%85/1.png" alt="1"><br>点download<br><img src="/2020/10/01/QGC%E5%AE%89%E8%A3%85/2.png" alt="2"><br>在Windows下点蓝字就可以开始下载，但是下载有点慢</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装就很简单</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QGC安装&quot;&gt;&lt;a href=&quot;#QGC安装&quot; class=&quot;headerlink&quot; title=&quot;QGC安装&quot;&gt;&lt;/a&gt;QGC安装&lt;/h1&gt;&lt;p&gt;大部分的教程都太老了所以整理了一下自己写了一套&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; clas</summary>
      
    
    
    
    <category term="安装" scheme="http://github.com/categories/%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="Windows" scheme="http://github.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>HSV颜色识别且标注</title>
    <link href="http://github.com/2020/05/31/HSV%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB%E4%B8%94%E6%A0%87%E6%B3%A8/"/>
    <id>http://github.com/2020/05/31/HSV%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB%E4%B8%94%E6%A0%87%E6%B3%A8/</id>
    <published>2020-05-31T06:54:12.000Z</published>
    <updated>2021-02-06T13:31:51.978Z</updated>
    
    <content type="html"><![CDATA[<p><font color="HotPink">色调H</font><br>用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°</p><p><font color="HotPink">饱和度S</font><br>饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和</p><p><font color="HotPink">明度V</font><br>明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）</p><h2 id="HSV表"><a href="#HSV表" class="headerlink" title="HSV表"></a>HSV表</h2><p><img src="/2020/05/31/HSV%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB%E4%B8%94%E6%A0%87%E6%B3%A8/1.png" alt></p><p><font color="DarkOrchid">如果想用的颜色不在HSV表里可以去查想要的颜色色号的rgb值，然后用<code>cv2.cvtcolor()</code>函数将bgr转成hsv<br>例如：</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">color = np.uint8([[[<span class="number">203</span>, <span class="number">192</span>, <span class="number">255</span>]]])</span><br><span class="line">hsv = cv2.cvtColor(color, cv2.COLOR_BGR2HSV)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">## 完整代码(视频中)</span></span><br><span class="line">```Python</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">lower_green = np.array([<span class="number">35</span>, <span class="number">110</span>, <span class="number">106</span>])</span><br><span class="line">upper_green = np.array([<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">'F:/test/mp4.mp4'</span>)</span><br><span class="line"><span class="keyword">if</span> cap.isOpened():</span><br><span class="line">    flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        hsv_img = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line">        mask_green = cv2.inRange(hsv_img, lower_green, upper_green)</span><br><span class="line"></span><br><span class="line">        mask_green = cv2.medianBlur(mask_green, <span class="number">7</span>)</span><br><span class="line">        mask_green, contours, hierarchy = cv2.findContours(mask_green, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</span><br><span class="line">            (x, y, w, h) = cv2.boundingRect(cnt)</span><br><span class="line">            cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">            cv2.putText(frame, <span class="string">"Green"</span>, (x, y - <span class="number">5</span>), font, <span class="number">0.7</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        num = num + <span class="number">1</span></span><br><span class="line">        cv2.imshow(<span class="string">"dection"</span>, frame)</span><br><span class="line">        cv2.imwrite(<span class="string">"imgs/%d.jpg"</span> % num, frame)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">20</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font color=&quot;HotPink&quot;&gt;色调H&lt;/font&gt;&lt;br&gt;用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°&lt;/p&gt;
&lt;p&gt;&lt;font col</summary>
      
    
    
    
    <category term="视觉" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89/"/>
    
    <category term="OpenCV" scheme="http://github.com/categories/%E8%A7%86%E8%A7%89/OpenCV/"/>
    
    
    <category term="Python" scheme="http://github.com/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://github.com/tags/OpenCV/"/>
    
  </entry>
  
</feed>
